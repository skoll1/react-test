<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <ul>
        <li>
            prototype的副作用：原型域并不是一种值复制行为，而是一种值引用现象，通过原型链，实现继承，但是如果改变某个原型上的引用类的属性值，也会影响到改原型作用的所有实例对象。
        </li>
        <li>
            多重继承：一个子类拥有任意多个超类
        </li>
        <li>
            超元类：一个子类可以被多个类继承。
        </li>
        <li>
            类的封装，私有变量。
            <ul>
                <li>
                    函数作用于内的方法无法被外界访问。
                </li>
            </ul>
        </li>
        <li>
            类的静态方法：在静态成员的类上操作的，而不是在实例上操作的。Math，Global都是静态对象。
            <ul>
                <li>
                    私有方法
                </li>
                <li>
                    公有方法。
                </li>
            </ul>
        </li>
        <li>
            方法的重载和覆盖
            <ul>
                <li>
                    重载：同名方法可以有的多个实现。通过arguments的属性来实现不同的方法。不管传入多少参数，也不管参数的类型。结合instanceof 和 constructor来判断每个参数的类型，来决定使用什么操作。
                </li>
                <li>
                    覆盖：子类的方法和超类的方法同名。且参数个数和类型相同，当子类被实例化之后，从超类中继承的方法将被隐藏。
                </li>
            </ul>
        </li>
        <li>
            类多态的原因：类型的模糊和类型的识别。js是一种弱类型的语言，通过typeof 运算符来判断值得类型，来实现不同的方法。
        </li>
        <li>
            类的生命周期函数
            <ul>
                <li>
                    出生：构造函数。new 运算符调用的就是构造函数，构造函数被new 调用之后，将返回实例对象，也就是所谓的对象初始化，对象的诞生。
                </li>
                <li>
                    如果构造函数有返回值，且返回值是引用类型，那么经过new 运算计算后，返回的不再是实例对象，而是引用值。
                </li>
                <li>
                    死亡：构析， 由于自动回收机制，当对象使用完毕的时候，js调用对象的回收程序来销毁内存中的对象，这个回收程序相当于一个构析函数。
                </li>
            </ul>
        </li>
        <li>
            超类：
            <ul>
                <li>
                    在js中Object是对象的通用类，其他所有的内置对象和自定义的构造对象都是专类，也就是说，其他所有内置对象和自定义构造对象都是Object对象的子类。因此，所有对象都会用用Object对象定义的属性和方法。
    
                </li>
                <li>
                    js语言的继承机制是通过原型继承来实现，而不是通过类继承来实现。因此。所有的原型对象都会继承Object.prototype的属性和方法
                </li>
                <li>
                    默认情况下。类的原型对象构造器应该指向类本身，也就是说prototype.constructor属性总是指向类自身。但是，如果我们把父类的实例传递给子类的prototype属性，那么就会破坏原型对象和默认构造器的引用关系，从而指向父类实例的构造器，从而引发构造器混乱。所以，需要我们手工修正子类原型对象的构造器引用。
                    <!-- 128行 -->
                </li>
            </ul>
        </li>
        <li>
            元类:创建类的类
            <ul>
                <li>
                    元类就是能够接受类作为参数的类，那就是元类操作的对象是类，而不是具体的数据。一般元类返回的是类，而不是具体的数据。
                </li>
            </ul>
        </li>
    </ul>
    <script>
        function Person(name){
            this.name=name
        }    
        Person.prototype={
            getName(){
                return this.name;
            }
        }

        function P2(age){
            this.age=age;
        }
        P2.prototype=new Person('lll');
        // 原型继承
        P2.prototype={
            getAge(){
                return this.age;
            }
        }
        // 原型继承
        // 23-25行的代码只能选择一个实现，不能支持多重继承。

        var a=new P2(22);


        // 类继承
        function A(x){
            this.x=x;
        }
        A.prototype.get=function(){
            return this.x;
        }

        function B(x,y){
            this.y=y;
            if(typeof x=='string'||typeof y =='number'){
                A.call(this,x);
                // 根据条件动态构造对象。
            }
            // 只是相当于执行了,只是多了这么一行代码，就可以使用prototype之后继续添加新的绑定。
            // this.x=x这一行。
        }
        B.prototype=new A()
        B.prototype.constructor=B
        // 恢复b的原型对象为构造方法b
        // 当定义构造函数的时候，其原型对象是默认Object一个类的实例，其构造器会被默认设置为该结构函数本身。如果改动prototyp的值，那么新的对象就不会是原来的值，指向另一个对象，那么新的对象就不会拥有原来的constructor属性值，所以必须重新设置constructor.
        B.prototype.getB=function(){
            return this.y;
        }
        var b=new B(1,2);
        // console.log(b);

        // 复制继承

        // 核心：for循环遍历对象，然后逐一复制给另一个对象。
        // 缺点：
        // for循环无法继承非枚举的方法，对于系统对象的只读方法和属性的继承也无效,如果父类的成员是引用成员，那么继承之后会带来一些列副作用。

    
    </script>
</body>
</html>